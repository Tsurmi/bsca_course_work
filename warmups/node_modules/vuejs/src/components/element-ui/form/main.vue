<template>
    <div class="nftn-el-form">
        <el-form
            ref="form"
            v-bind:label-position="labelPosition"
            v-bind:label-width="labelWidth + 'px'"
            v-bind:model="formData">
            <nftn-el-grid v-bind:configs="grid">
                <template
                    v-for="(slot, sloti) in computedInputGridSlots"
                    v-bind:slot="'grid-' + slot.name">
                        <nftn-el-input
                            v-for="(input, inputi) in slot.inputs"
                            v-bind:key="'input:' + inputi"
                            v-bind:configs="input"
                            v-model="formData[input.name]"
                            v-if="!computedGridSlots['grid-' + slot.name]">
                            <template slot="label" v-if="$slots[input.name + '.label']">
                                <slot v-bind:name="input.name + '.label'"></slot>
                            </template>
                            <template slot="input" v-if="$slots[input.name + '.input']">
                                <slot v-bind:name="input.name + '.input'"></slot>
                            </template>
                        </nftn-el-input>
                </template>
                <template
                    v-for="(slot, sloti) in computedGridSlots"
                    v-bind:slot="slot">
                    <slot v-bind:name="slot"></slot>
                </template>
                <template v-bind:slot="'grid-' + actionGrid">
                    <el-button type="primary" v-on:click="handleSubmit">提交</el-button>
                    <el-button v-on:click="handleReset">重置</el-button>
                </template>
            </nftn-el-grid>
        </el-form>
    </div>
</template>

<script>
    import ObjectHelper from '@/helpers/object';
    import Vue from 'vue';
    import Element from 'element-ui';
    import NftnElInput from './input';
    import '../grid';

    Vue.use(Element);

    let watchers = [];

    export default {
        name: 'nftn-el-form',
        components: {
            NftnElInput
        },
        props: {
            grid: {
                type: [Object, Array],
                default () { return {}; }
            },
            actionGrid: {
                type: String,
                default () {
                    let grid = this.grid.rows;
                    let rows = grid instanceof Array ? grid : grid.rows;
                    let cols = [rows.length - 1].cols instanceof Array ? rows[rows.length - 1].cols : rows[rows.length - 1];
                    return (rows.length - 1) + '-' + (cols.length - 1);
                }
            },
            labelPosition: {
                type: String,
                default: 'top'
            },
            labelWidth: {
                type: Number,
                default: 80
            },
            inputs: {
                type: Array,
                default () { return []; }
            },
            rules: {
                type: Object,
                default () { return {}; }
            },
            value: { // v-model
                type: Object,
                default () { return {}; }
            }
        },
        methods: {
            getGridSlots () {
                let slots = [];
                let result = {};
                let existsRules = {};

                this.inputs.forEach(input => {
                    let gridSlot = input.grid || '0-0';
                    if (slots.indexOf(gridSlot) === -1) {
                        slots.push(gridSlot);
                        result[gridSlot] = { name: gridSlot, inputs: [] };
                    }
                    let rules = this.rules[input.name];
                    if (rules && !existsRules[input.name]) {
                        if (!input.rules) {
                            input.rules = [];
                        } else if (typeof input.rules === 'object' && !(input.rules instanceof Array)) {
                            input.rules = [input.rules];
                        }

                        if (rules instanceof Array) {
                            input.rules = input.rules.concat(rules);
                        } else {
                            input.rules.push(rules);
                        }
                        existsRules[input.name] = input.rules;
                    }
                    result[gridSlot].inputs.push(input);
                });

                return result;
            },
            handleSubmit () {
                this.$refs['form'].validate(valid => {
                    if (valid) {
                        alert('submit!');
                    } else {
                        console.log('error submit!!');
                        return false;
                    }
                });
            },
            handleReset () {
                this.reset = true;
                this.$refs['form'].resetFields();
            },
            isMultipleInput (input) {
                return input.type === 'checkbox' || input.multiple;
            }
        },
        computed: {
            computedGridSlots () {
                // 提取父组件设置的 slots 里关于 grid 的部分
                return Object.keys(this.$slots).filter(slot => slot.indexOf('grid-') === 0);
            },
            computedInputGridSlots () {
                // 根据表单项的设置自动生成 grid slots 并排除父组件设置的 grid slots
                let slots = this.getGridSlots();
                let slotKeys = Object.keys(slots);
                slotKeys.forEach(slot => {
                    if (this.computedGridSlots.indexOf('grid-' + slot) >= 0) {
                        delete slots[slot];
                    }
                });
                return slots;
            }
        },
        data () {
            return {
                reset: false,
                formData: this.value
            };
        },
        watch: {
            inputs: {
                handler (newValue, oldValue) {
                    watchers.forEach(watcher => {
                        if (typeof watcher === 'function') {
                            watcher();
                        };
                    });

                    let formData = JSON.parse(JSON.stringify(this.formData));
                    this.inputs.forEach(input => {
                        let inputname = input.name;
                        if (inputname && !formData[inputname]) {
                            formData[inputname] = this.isMultipleInput(input) ? [] : '';
                        }

                        let value = formData[inputname];
                        if (this.isMultipleInput(input) && !(value instanceof Array)) {
                            formData[inputname] = [value];
                        }

                        if (input.rules) {
                            watchers.push(this.$watch('formData.' + inputname, (nv, ov) => {
                                if (!this.reset) {
                                    this.$refs['form'].validateField(inputname);
                                }
                                this.reset = false;
                            }));
                        }

                        let cascade = input.cascade || {};
                        if (cascade && cascade.parent) {
                            let handleCascade = (value) => {
                                if (value) {
                                    let pinput = this.inputs.filter(pinput => {
                                        return pinput.name === cascade.parent;
                                    })[0];
                                    if (pinput) {
                                        let pinputSelectedItem = pinput.datasource.filter(item => {
                                            return JSON.stringify(item[pinput.valueKey || 'value']) === JSON.stringify(value);
                                        })[0];
                                        if (pinputSelectedItem) {
                                            let datasource = ObjectHelper.deep.getValue(pinputSelectedItem, cascade.key);
                                            if (!datasource) {
                                                datasource = ObjectHelper.deep.getValue(window, cascade.key);
                                            }
                                            input.datasource = datasource || [];
                                        }
                                    }
                                }
                            };
                            watchers.push(this.$watch('formData.' + cascade.parent, (nv, ov) => {
                                formData[inputname] = input.multiple ? [] : '';
                                input.datasource = [];
                                handleCascade(nv);
                            }));
                            handleCascade(formData[cascade.parent]);
                        }
                    }); // this.inputs.forEach()

                    this.formData = formData;
                },
                deep: true,
                immediate: true
            },
            formData: {
                handler (newValue, oldValue) {
                    this.$emit('input', newValue);
                },
                deep: true,
                immediate: true
            }
        },
        created () {

        },
        mounted () {
        }
    };
</script>
